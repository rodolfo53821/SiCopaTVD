<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Mon May 14 13:42:56 PDT 2001 -->
<TITLE>
HAVi Java APIs 1.1 May 15, 2001: Class  HAnimateLook
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<I>HAVi Java APIs 1.1 May 15, 2001</I></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../org/havi/ui/HAnimation.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="HAnimateLook.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.havi.ui</FONT>
<BR>
Class  HAnimateLook</H2>
<PRE>
java.lang.Object
  |
  +--<B>org.havi.ui.HAnimateLook</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable, <A HREF="../../../org/havi/ui/HLook.html">HLook</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>HAnimateLook</B><DT>extends java.lang.Object<DT>implements <A HREF="../../../org/havi/ui/HLook.html">HLook</A></DL>

<P>
The <A HREF="../../../org/havi/ui/HAnimateLook.html"><CODE>HAnimateLook</CODE></A>
class is used by any <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> component to display animated graphical content. 
This look will be provided by the platform and the exact way in
which it is rendered will be platform dependant.

<p> 
The <A HREF="../../../org/havi/ui/HAnimateLook.html"><CODE>HAnimateLook</CODE></A> class draws the content set on an <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A>. It uses the <A HREF="../../../org/havi/ui/HVisible.html#getAnimateContent(int)"><CODE>getAnimateContent(int
state)</CODE></A> method with the current state of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> to determine the content to render.
Additionally the content-based behavior of the <A HREF="../../../org/havi/ui/HAnimateLook.html"><CODE>HAnimateLook</CODE></A> class is
defined as follows:

<ul>
<li> If there is only one image referenced in the sequence then
that image is rendered statically in a similar manner to <A HREF="../../../org/havi/ui/HGraphicLook.html"><CODE>HGraphicLook</CODE></A>.

<li> If there is more than one image referenced in the sequence
then these are rendered in sequence, giving the effect of an
animation.
</ul>

If a referenced image is inaccessible, then it shall be skipped. 

<p>
The <A HREF="../../../org/havi/ui/HAnimateLook.html"><CODE>HAnimateLook</CODE></A> is not required to present consecutive images in the
animation with the delay specified in its associated <A HREF="../../../org/havi/ui/HStaticAnimation.html"><CODE>HStaticAnimation</CODE></A>. For example, if the
time taken to retrieve or render an image is longer than the delay,
then then it shall be rendered as soon as possible.

<p> 
Implementations of <A HREF="../../../org/havi/ui/HAnimateLook.html"><CODE>HAnimateLook</CODE></A> should use the appropriate methods on
<A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> to determine which scaling
and alignment modes to use when rendering content. See the class
description for <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> for more
details. <A HREF="../../../org/havi/ui/HAnimateLook.html"><CODE>HAnimateLook</CODE></A> may support scalable animated graphical content. As
a minimum, all implementations must support the <A HREF="../../../org/havi/ui/HVisible.html#RESIZE_NONE"><CODE>RESIZE_NONE</CODE></A> scaling
mode, and all alignment modes.

<p> 
Note that the results of applying the <A HREF="../../../org/havi/ui/HVisible.html#VALIGN_JUSTIFY"><CODE>VALIGN_JUSTIFY</CODE></A> and <A HREF="../../../org/havi/ui/HVisible.html#HALIGN_JUSTIFY"><CODE>HALIGN_JUSTIFY</CODE></A> alignment modes
for animated graphical content are defined to identical to <A HREF="../../../org/havi/ui/HVisible.html#VALIGN_CENTER"><CODE>VALIGN_CENTER</CODE></A> and <A HREF="../../../org/havi/ui/HVisible.html#HALIGN_CENTER"><CODE>HALIGN_CENTER</CODE></A> modes
respectively, as justification is meaningless in this context.

<p> 
This is the default look that is used by <A HREF="../../../org/havi/ui/HStaticAnimation.html"><CODE>HStaticAnimation</CODE></A> and its subclasses.

<hr>
The parameters to the constructors are as follows, in cases where
parameters are not used, then the constructor should use the default
values.
<p>
<h3>Default parameter values exposed in the constructors</h3>
<table border>
<tr><th>Parameter</th><th>Description</th><th>Default value</th> 
<th>Set method</th><th>Get method</th></tr>
<tr><td colspan=5>None.</td></tr>
</table>
<h3>Default parameter values not exposed in the constructors</h3>
<table border>
<tr><th>Description</th><th>Default value</th><th>Set method</th>
<th>Get method</th></tr>
<tr><td colspan=4>None.</td></tr>
</table>
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../../org/havi/ui/HStaticAnimation.html"><CODE>HStaticAnimation</CODE></A>, 
<A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A>, 
<A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/havi/ui/HAnimateLook.html#HAnimateLook()">HAnimateLook</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <A HREF="../../../org/havi/ui/HAnimateLook.html"><CODE>HAnimateLook</CODE></A> object.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Insets</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/havi/ui/HAnimateLook.html#getInsets(org.havi.ui.HVisible)">getInsets</A></B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;visible)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines the insets of this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>,
 which indicate the size of the border.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Dimension</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/havi/ui/HAnimateLook.html#getMaximumSize(org.havi.ui.HVisible)">getMaximumSize</A></B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;hvisible)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the maximum size of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> component when drawn with this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Dimension</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/havi/ui/HAnimateLook.html#getMinimumSize(org.havi.ui.HVisible)">getMinimumSize</A></B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;hvisible)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the minimum size of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> component when drawn with this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Dimension</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/havi/ui/HAnimateLook.html#getPreferredSize(org.havi.ui.HVisible)">getPreferredSize</A></B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;hvisible)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the preferred size of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> component when drawn with this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/havi/ui/HAnimateLook.html#isOpaque(org.havi.ui.HVisible)">isOpaque</A></B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;visible)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the entire painted area of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> when using this look is fully opaque,
 i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/havi/ui/HAnimateLook.html#showLook(java.awt.Graphics, org.havi.ui.HVisible, int)">showLook</A></B>(java.awt.Graphics&nbsp;g,
         <A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;visible,
         int&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <A HREF="../../../org/havi/ui/HLook.html#showLook(java.awt.Graphics, org.havi.ui.HVisible, int)"><CODE>showLook</CODE></A> method is
 responsible for repainting the entire <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> component, (including any
 content set on the component, and the component background), subject to
 the clipRect of the Graphics object passed to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/havi/ui/HAnimateLook.html#widgetChanged(org.havi.ui.HVisible, org.havi.ui.HChangeData[])">widgetChanged</A></B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;visible,
              <A HREF="../../../org/havi/ui/HChangeData.html">HChangeData</A>[]&nbsp;changes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Called by the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> whenever
 its content, state, or any other data changes.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="HAnimateLook()"><!-- --></A><H3>
HAnimateLook</H3>
<PRE>
public <B>HAnimateLook</B>()</PRE>
<DL>
<DD>Creates a <A HREF="../../../org/havi/ui/HAnimateLook.html"><CODE>HAnimateLook</CODE></A> object. See the class description for
 details of constructor parameters and default values.</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="showLook(java.awt.Graphics, org.havi.ui.HVisible, int)"><!-- --></A><H3>
showLook</H3>
<PRE>
public void <B>showLook</B>(java.awt.Graphics&nbsp;g,
                     <A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;visible,
                     int&nbsp;state)</PRE>
<DL>
<DD>The <A HREF="../../../org/havi/ui/HLook.html#showLook(java.awt.Graphics, org.havi.ui.HVisible, int)"><CODE>showLook</CODE></A> method is
 responsible for repainting the entire <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> component, (including any
 content set on the component, and the component background), subject to
 the clipRect of the Graphics object passed to it.
 <p>
 The <A HREF="../../../org/havi/ui/HLook.html#showLook(java.awt.Graphics, org.havi.ui.HVisible, int)"><CODE>showLook</CODE></A> method should
 not modify the clipRect of the <code>Graphics</code> object
 that is passed to it.
 <p> 
 For looks which draw content (e.g.  <A HREF="../../../org/havi/ui/HTextLook.html"><CODE>HTextLook</CODE></A>, <A HREF="../../../org/havi/ui/HGraphicLook.html"><CODE>HGraphicLook</CODE></A> and <A HREF="../../../org/havi/ui/HAnimateLook.html"><CODE>HAnimateLook</CODE></A>), if no content is
 associated with the component, the <A HREF="../../../org/havi/ui/HLook.html#showLook(java.awt.Graphics, org.havi.ui.HVisible, int)"><CODE>showLook</CODE></A> method paints the component
 with its current background <code>Color</code> according to the <A HREF="../../../org/havi/ui/HVisible.html#setBackgroundMode(int)"><CODE>setBackgroundMode</CODE></A>
 method of <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> and draws any
 (implementation-specific) borders. Note that by default the
 background mode is set so as to <b>not</b> paint a
 background. Furthermore on platforms which support transparent
 colors the background <code>Color</code> may be partially or completely
 transparent.
 <p> 
 Any resources <b>explicitly</b> associated with an <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> should be loaded by the <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> during its creation, etc. 
 Note that the &quot;standard&quot; looks don't load content by default. 
 <p>
 This method is called from the <A HREF="../../../org/havi/ui/HVisible.html#paint(java.awt.Graphics)"><CODE>paint</CODE></A> method of <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> and must never be called from
 elsewhere. Components wishing to redraw themselves should call
 their repaint method in the usual way.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../../org/havi/ui/HLook.html#showLook(java.awt.Graphics, org.havi.ui.HVisible, int)">showLook</A></CODE> in interface <CODE><A HREF="../../../org/havi/ui/HLook.html">HLook</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the graphics context.<DD><CODE>visible</CODE> - the visible.<DD><CODE>state</CODE> - the state parameter indicates the state of the
 visible, allowing the look to render the appropriate content
 for that state. Note that some components (e.g. HStaticRange,
 HRange, HRangeValue) do not use state-based content).</DL>
</DD>
</DL>
<HR>

<A NAME="widgetChanged(org.havi.ui.HVisible, org.havi.ui.HChangeData[])"><!-- --></A><H3>
widgetChanged</H3>
<PRE>
public void <B>widgetChanged</B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;visible,
                          <A HREF="../../../org/havi/ui/HChangeData.html">HChangeData</A>[]&nbsp;changes)</PRE>
<DL>
<DD>Called by the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> whenever
 its content, state, or any other data changes. See the class
 description of <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> for more
 information about the <code>changes</code> parameter.
 <p>
 The implementation of this method should work out which
 graphical areas of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A>
 have changed and make any relevant calls to trigger the
 repainting of those areas.
 <p>
 A minimum implementation of this method could simply call
 <pre>
 visible.repaint()
 </pre><DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../../org/havi/ui/HLook.html#widgetChanged(org.havi.ui.HVisible, org.havi.ui.HChangeData[])">widgetChanged</A></CODE> in interface <CODE><A HREF="../../../org/havi/ui/HLook.html">HLook</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>visible</CODE> - the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> which
 has changed<DD><CODE>changes</CODE> - an array containing hint data and associated hint
 objects. If this argument is <code>null</code> a full repaint
 will be triggered.</DL>
</DD>
</DL>
<HR>

<A NAME="getMinimumSize(org.havi.ui.HVisible)"><!-- --></A><H3>
getMinimumSize</H3>
<PRE>
public java.awt.Dimension <B>getMinimumSize</B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;hvisible)</PRE>
<DL>
<DD>Gets the minimum size of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> component when drawn with this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>. 
 <p>
 This size may be determined in several ways depending on the
 information available to the look. These steps are performed in
 order and the first available result is returned. For the
 purposes of this algorithm <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>
 classes that do not use content (e.g. <A HREF="../../../org/havi/ui/HRangeLook.html"><CODE>HRangeLook</CODE></A>) are treated as if no
 content was present.
 <p>
 The extra space required for border decoration can be determined from 
 the <A HREF="../../../org/havi/ui/HLook.html#getInsets(org.havi.ui.HVisible)"><CODE>getInsets</CODE></A> method.
 <p><ol>
 
 <li> If this look is an <A HREF="../../../org/havi/ui/HTextLook.html"><CODE>HTextLook</CODE></A> and 
 if <A HREF="../../../org/havi/ui/HVisible.html#getTextLayoutManager()"><CODE>HVisible.getTextLayoutManager()</CODE></A> returns an <A HREF="../../../org/havi/ui/HDefaultTextLayoutManager.html"><CODE>HDefaultTextLayoutManager</CODE></A>, then
 this method should delegate the call to its <A HREF="../../../org/havi/ui/HDefaultTextLayoutManager.html#getMinimumSize(org.havi.ui.HVisible)"><CODE>getMinimumSize()</CODE></A>
 method plus any additional dimensions that the HLook requires for border 
 decoration etc. If the HDefaultTextLayoutManager returns a zero size, then 
 proceed with the following steps.
 <li> If the <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> supports the
 scaling of its content (e.g. an <A HREF="../../../org/havi/ui/HGraphicLook.html"><CODE>HGraphicLook</CODE></A>) and content is set then the return value is the
 size of the smallest piece of content plus any additional
 dimensions that the HLook requires for border decoration etc.
 <li> If the <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> does not support
 scaling of content or no scaling is requested, <em>and</em>
 content is set then the return value is the size of the largest
 piece of content plus any additional dimensions that the HLook
 requires for border decoration etc.
 <li> If no content is available but a default preferred size
 has been set using <A HREF="../../../org/havi/ui/HVisible.html#setDefaultSize(java.awt.Dimension)"><CODE>setDefaultSize</CODE></A> has been called to set then the return value is
 this value (as obtained with <A HREF="../../../org/havi/ui/HVisible.html#getDefaultSize()"><CODE>getDefaultSize</CODE></A>) plus any
 additional dimensions that the HLook requires for border
 decoration etc.
 <li> If there is no content or default size set then the
 return value is an implementation-specific minimum size plus
 any additional dimensions that the HLook requires for border
 decoration etc.
 </ol><DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../../org/havi/ui/HLook.html#getMinimumSize(org.havi.ui.HVisible)">getMinimumSize</A></CODE> in interface <CODE><A HREF="../../../org/havi/ui/HLook.html">HLook</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hvisible</CODE> - <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> to which
 this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> is attached.<DT><B>Returns:</B><DD>A dimension object indicating this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook's</CODE></A> minimum size.<DT><B>See Also: </B><DD><A HREF="../../../org/havi/ui/HVisible.html#getMinimumSize()"><CODE>HVisible.getMinimumSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPreferredSize(org.havi.ui.HVisible)"><!-- --></A><H3>
getPreferredSize</H3>
<PRE>
public java.awt.Dimension <B>getPreferredSize</B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;hvisible)</PRE>
<DL>
<DD>Gets the preferred size of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> component when drawn with this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>. 
 <p>
 This size may be determined in several ways depending on the
 information available to the look. These steps are performed in
 order and the first available result is returned. For the
 purposes of this algorithm <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>
 classes that do not use content (e.g. <A HREF="../../../org/havi/ui/HRangeLook.html"><CODE>HRangeLook</CODE></A>) are treated as if no
 content was present.
 <p>
 The extra space required for border decoration can be determined from 
 the <A HREF="../../../org/havi/ui/HLook.html#getInsets(org.havi.ui.HVisible)"><CODE>getInsets</CODE></A> method.
 <p><ol>
 
 <li> If a default preferred size has been set for this <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> (using <A HREF="../../../org/havi/ui/HVisible.html#setDefaultSize(java.awt.Dimension)"><CODE>setDefaultSize</CODE></A>) then the
 return value is this size (obtained with <A HREF="../../../org/havi/ui/HVisible.html#getDefaultSize()"><CODE>getDefaultSize</CODE></A>) plus any
 additional dimensions that the HLook requires for border
 decoration etc.
 <li> If this look is an <A HREF="../../../org/havi/ui/HTextLook.html"><CODE>HTextLook</CODE></A> and if a default preferred size has not been set and <A HREF="../../../org/havi/ui/HVisible.html#getTextLayoutManager()"><CODE>HVisible.getTextLayoutManager()</CODE></A> returns an <A HREF="../../../org/havi/ui/HDefaultTextLayoutManager.html"><CODE>HDefaultTextLayoutManager</CODE></A>, then
 this method should delegate the call to its <A HREF="../../../org/havi/ui/HDefaultTextLayoutManager.html#getPreferredSize(org.havi.ui.HVisible)"><CODE>getPreferredSize()</CODE></A> method plus any additional dimensions that the HLook 
 requires for border decoration etc. If the HDefaultTextLayoutManager returns 
 a zero size, then proceed with the following steps.
 <li> If this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> does not support
 scaling of content or no scaling is requested, and content is
 present then the return value is the size of the largest piece
 of content plus any additional dimensions that the HLook
 requires for border decoration etc.
 <li> If this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> supports the
 scaling of its content (e.g. an <A HREF="../../../org/havi/ui/HGraphicLook.html"><CODE>HGraphicLook</CODE></A>) and content is set then the return value is the
 current size of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> as
 returned by <CODE>getSize</CODE>).
 <li>If there is no content and no default size set then the
 return value is the current size of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> as returned by <CODE>getSize</CODE>).
 </ol><DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../../org/havi/ui/HLook.html#getPreferredSize(org.havi.ui.HVisible)">getPreferredSize</A></CODE> in interface <CODE><A HREF="../../../org/havi/ui/HLook.html">HLook</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hvisible</CODE> - <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> to which
 this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> is attached.<DT><B>Returns:</B><DD>A dimension object indicating the preferred size of the
 <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> when drawn with this
 <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>.<DT><B>See Also: </B><DD><A HREF="../../../org/havi/ui/HVisible.html#getPreferredSize()"><CODE>HVisible.getPreferredSize()</CODE></A>, 
<A HREF="../../../org/havi/ui/HVisible.html#setDefaultSize(java.awt.Dimension)"><CODE>HVisible.setDefaultSize(java.awt.Dimension)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumSize(org.havi.ui.HVisible)"><!-- --></A><H3>
getMaximumSize</H3>
<PRE>
public java.awt.Dimension <B>getMaximumSize</B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;hvisible)</PRE>
<DL>
<DD>Gets the maximum size of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> component when drawn with this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>. 
 <p>
 This size may be determined in several ways depending on the
 information available to the look. These steps are performed in
 order and the first available result is returned. For the
 purposes of this algorithm <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>
 classes that do not use content (e.g. <A HREF="../../../org/havi/ui/HRangeLook.html"><CODE>HRangeLook</CODE></A>) are treated as if no
 content was present.
 <p>
 The extra space required for border decoration can be determined from 
 the <A HREF="../../../org/havi/ui/HLook.html#getInsets(org.havi.ui.HVisible)"><CODE>getInsets</CODE></A> method.
 <p><ol>
 <li> If this look is an <A HREF="../../../org/havi/ui/HTextLook.html"><CODE>HTextLook</CODE></A> and if 
 <A HREF="../../../org/havi/ui/HVisible.html#getTextLayoutManager()"><CODE>HVisible.getTextLayoutManager()</CODE></A> returns an <A HREF="../../../org/havi/ui/HDefaultTextLayoutManager.html"><CODE>HDefaultTextLayoutManager</CODE></A>, then
 this method should delegate the call to its <A HREF="../../../org/havi/ui/HDefaultTextLayoutManager.html#getMaximumSize(org.havi.ui.HVisible)"><CODE>getMaximumSize()</CODE></A>
 method plus any additional dimensions that the HLook requires for border 
 decoration etc. If the HDefaultTextLayoutManager returns a zero size, then 
 proceed with the following steps.
 <li> If the <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> supports the
 scaling of its content (e.g. an <A HREF="../../../org/havi/ui/HGraphicLook.html"><CODE>HGraphicLook</CODE></A>) then the return value is the current size of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> (as returned by <CODE>HVisible#getSize</CODE>).
 <li> If the <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> does not support
 scaling of content or no scaling is requested, and content is
 set then the return value is the size of the largest piece of
 content plus any additional dimensions that the HLook requires
 for border decoration etc.
 <li> If there is no content set then a maximum size of
 <code>[Short.MAX_VALUE, Short.MAX_VALUE]</code> is returned as
 a Dimension.     
 </ol><DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../../org/havi/ui/HLook.html#getMaximumSize(org.havi.ui.HVisible)">getMaximumSize</A></CODE> in interface <CODE><A HREF="../../../org/havi/ui/HLook.html">HLook</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hvisible</CODE> - <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> to which
 this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> is attached.<DT><B>Returns:</B><DD>A dimension object indicating this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook's</CODE></A> maximum size.<DT><B>See Also: </B><DD><A HREF="../../../org/havi/ui/HVisible.html#getMaximumSize()"><CODE>HVisible.getMaximumSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isOpaque(org.havi.ui.HVisible)"><!-- --></A><H3>
isOpaque</H3>
<PRE>
public boolean <B>isOpaque</B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;visible)</PRE>
<DL>
<DD>Returns true if the entire painted area of the <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> when using this look is fully opaque,
 i.e. the <A HREF="../../../org/havi/ui/HLook.html#showLook(java.awt.Graphics, org.havi.ui.HVisible, int)"><CODE>showLook</CODE></A> method
 guarantees that all pixels are painted in an opaque Color.
 <p>
 The default value is implementation specific and depends on the
 background painting mode of the given <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A>. The consequences of an invalid
 overridden value are implementation specific.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../../org/havi/ui/HLook.html#isOpaque(org.havi.ui.HVisible)">isOpaque</A></CODE> in interface <CODE><A HREF="../../../org/havi/ui/HLook.html">HLook</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>visible</CODE> - the visible to test<DT><B>Returns:</B><DD>true if all the pixels with the
 java.awt.Component#getBounds method of an <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> using this look are fully
 opaque, i.e.  the <A HREF="../../../org/havi/ui/HLook.html#showLook(java.awt.Graphics, org.havi.ui.HVisible, int)"><CODE>showLook</CODE></A>
 method guarantees that all pixels are painted in an opaque
 Color, otherwise false.</DL>
</DD>
</DL>
<HR>

<A NAME="getInsets(org.havi.ui.HVisible)"><!-- --></A><H3>
getInsets</H3>
<PRE>
public java.awt.Insets <B>getInsets</B>(<A HREF="../../../org/havi/ui/HVisible.html">HVisible</A>&nbsp;visible)</PRE>
<DL>
<DD>Determines the insets of this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>,
 which indicate the size of the border. This area is
 reserved for the <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> to use for
 drawing borders around the associated <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A>.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../../org/havi/ui/HLook.html#getInsets(org.havi.ui.HVisible)">getInsets</A></CODE> in interface <CODE><A HREF="../../../org/havi/ui/HLook.html">HLook</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hvisible</CODE> - <A HREF="../../../org/havi/ui/HVisible.html"><CODE>HVisible</CODE></A> to which
 this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A> is attached.<DT><B>Returns:</B><DD>the insets of this <A HREF="../../../org/havi/ui/HLook.html"><CODE>HLook</CODE></A>.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<I>HAVi Java APIs 1.1 May 15, 2001</I></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../org/havi/ui/HAnimation.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="HAnimateLook.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<FONT SIZE="-1"><FONT COLOR = "red">The HAVi Specification: Appendix A HAVi Java APIs. <br>Copyright 2001 by The HAVi,  Inc. <br>Java is a trademark of Sun Microsystems, Inc. <br>All rights reserved. <br></FONT></FONT>
</BODY>
</HTML>
