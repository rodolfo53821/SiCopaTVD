<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.73 [en] (X11; U; SunOS 5.6 sun4u) [Netscape]">
   <title>Java TV Security</title>
<!
  @(#)security.html	1.6 00/09/22
 
  Copyright 1998-2000 by Sun Microsystems, Inc.,
  901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
  All rights reserved.
 
  This software is the confidential and proprietary information
  of Sun Microsystems, Inc. ("Confidential Information").  You
  shall not disclose such Confidential Information and shall use
  it only in accordance with the terms of the license agreement
  you entered into with Sun.
>
</head>
<body>

<h1>
<font color="#000000">Security in the Java TV<sup><font size=-1>TM</font></sup>
API</font></h1>

<h3>

<hr WIDTH="100%"></h3>
<font color="#000000">This document describes the security model used in
the Java TV<sup><font size=-2>TM</font></sup> API, including an <a href="#Overview">overview</a>
of security in the Java<sup><font size=-2>TM</font></sup> language, who
<a href="#Who Assigns">assigns
permissions</a> in the Java TV API, and the <a href="#PermissionsArch">permissions
architecture</a>.</font>
<h3>
<a NAME="Overview"></a><font color="#000000">Overview</font></h3>
<font color="#000000">The Java language's security model addresses permitting
or denying access to resources, based on the source of the code requesting
access. It is a tried and proven architecture that has benefited from years
of experience. In computer workstations and personal computers, the "source"
from which code comes is primarily determined by the site from which the
code is downloaded (often a URL), or by a trusted signer who has signed
the code.</font>
<p><font color="#000000">The Java language's security model is readily
applicable to interactive television and provides clear benefits. It allows
a responsible party to reliably prevent classes of code from accessing
resources that the code shouldn't need access to. For example, an advertising
application can be prevented from changing the channel to a network owned
by the advertiser, an application can be granted access to select only
certain services (such as those within a bouquet), an application can be
prevented from accessing the return channel, or it can be denied access
to a users' in-home network. Providing a simple, reliable mechanism to
deny such access provides important benefits, including cost reductions,
particularly in a horizontal market.</font>
<p><font color="#000000">It can be argued that applications could be exhaustively
tested to ensure that they don't misbehave. However, such testing is expensive
and difficult. The Java language's security model frees the broadcaster
from some of this testing, by allowing it to establish a "sandbox," which
constrains the actions of applications; the Java 2 Platform, Standard Edition
(J2SE), security model allows that sandbox to be easily configurable so
it can be expanded to fit the needs of a given application.</font>
<p><font color="#000000">In the J2SE security model, permissions are expressed
as subclasses of <tt>java.security.Permission</tt>. A method that detects
the violation of a security constraint does so by throwing a <tt>java.lang.SecurityException</tt>.
This is a subclass of <tt>java.lang.RuntimeException</tt>, but despite
this, any method of the Java TV API that can exit due to a SecurityException
must document this fact by:</font>
<ul>
<li>
<font color="#000000">Declaring "throws SecurityException" in the method
signature.</font></li>

<li>
<font color="#000000">Containing "@throws SecurityException" in the method's
documentation.</font></li>

<li>
<font color="#000000">Describing the permission required in the method's
documentation.</font></li>
</ul>
<font color="#000000">The J2SE security model is described in depth in
the book&nbsp;<a NAME="Inside Java 2 Platform"></a><i>Inside Java 2 Platform
Security</i> by Li Gong, ISBN 0-201-31000-7.</font>
<p><font color="#000000">For a horizontal market, the underlying platform
security should be based on the J2SE security model. The Java TV API might,
however, be applied in certain vertical markets that have modest security
requirements. For platforms such as this, the permission classes described
below will be considered optional if the underlying platform does not support
the J2SE security architecture. For all platforms that support the J2SE
security model, the permission classes are a required part of the Java
TV API.</font>
<h3>
<a NAME="Who Assigns"></a><font color="#000000">Who Assigns Permissions</font></h3>
<font color="#000000">Who is allowed to assign permissions is a critical
issue. The Java TV API does not dictate the policy underlying permission
setting. The model for who is trusted and who assigns permissions is an
important part of the business model underlying a complete platform for
interactive television. The Java technologies provide support for a variety
of signing models, but it is ultimately up to the entity that specifies
the complete platform to determine the model for granting permissions.</font>
<p><font color="#000000">In a closed network where the set-top box is owned
by the network operator, the responsible party would likely be the network
operator. In a horizontal market, the answer is less clear, given the following
considerations:</font>
<ul>
<li>
<font color="#000000">It is possible to establish a "minimum sandbox" that
allows applications to do interesting things, but does not allow them to
do anything damaging. This minimum sandbox will include at least all methods
that are not declared as throwing SecurityException. A given platform may
guarantee that a security exception is <b>not</b> thrown under certain
circumstances, thereby enlarging the minimum sandbox, but it may not allow
a security exception to be thrown where one is not declared.</font></li>

<li>
<font color="#000000">In a horizontal market, it is very useful if the
broadcaster can signal the set of permissions that they would like a given
application to have. In no case should the box give an application permissions
that the broadcaster didn't ask for. This relieves the broadcaster from
the responsibility of testing for access to these resources.</font></li>

<li>
<font color="#000000">If an application is signaled as wanting access to
a resource, that access might not be granted. Specifically, the owner of
the set-top box (i.e., the user at home, or a network operator who subsidizes
the box) might want to configure who is and isn't trusted to grant various
resources.</font></li>

<li>
<font color="#000000">In any given standards environment, it is possible
for the standards organization to define a set of permissions that must
be granted, if requested in the application signaling. For example, service
selection is a feature that probably should be granted to any application
that requests it, because a broadcaster can only use this feature to tune
<i>away</i>
from their service.</font></li>

<li>
<font color="#000000">For more sensitive resources, the application and
the list of permissions should be signed by the broadcaster. This avoids
attacks where an attacker spoofs a broadcaster, or otherwise illegally
inserts content. This signing requires legal and technical infrastructure
for each broadcaster to obtain a unique certificate from a trusted party,
and for the box to validate these certificates.</font></li>
</ul>

<h3>
<a NAME="PermissionsArch"></a><font color="#000000">Java TV API Permissions
Architecture</font></h3>
<font color="#000000">This section describes the permissions that exist
for the Java TV APIs. In addition to these permissions, there are the permissions
that exist in the underlying Java platform, and permissions for any other
APIs that are defined as part of a complete platform.</font>
<p><font color="#000000">In the Java TV API, many resources are accessed
with a Locator. Locators are used to:</font>
<ul>
<li>
<font color="#000000">Access data from an object carousel</font></li>

<li>
<font color="#000000">Access SI data</font></li>

<li>
<font color="#000000">Select a different service (i.e., tune to a different
channel)</font></li>

<li>
<font color="#000000">Retrieve program guide data</font></li>

<li>
<font color="#000000">Play a Media Stream</font></li>
</ul>
<font color="#000000">In many ways, a Locator is analogous to a file name
in a computer file system. In computers, a file name is often associated
with a hardware device, such as a printer and the screen ("prn:" and "con:"
in DOS-based systems, and /dev/lp* and /dev/tty in UNIX systems). Associating
permissions with files is a well established mechanism for restricting
access to data files, hardware devices, and other resources in computer
systems.</font>
<p><font color="#000000">The Java language model for access to a file system
is twofold: There is a file object (<tt>java.io.File</tt>), which represents
the path to an object in the file system, and there is a security check
based on that name. In the J2SE security model, that security check is
reified in the class <tt>java.io.FilePermission</tt>. A FilePermission
contains a path (or a regular expression denoting a set of paths), and
an <i>action string</i>. The action string can be <i>read</i>,
<i>write</i>,
<i>execute</i>
or <i>delete</i>. In the JDK 1.1 security model, the same facility is exposed
through a small number of check methods on <tt>java.lang.SecrityManager
</tt>(<tt>checkRead(String)</tt>,
etc.).</font>
<p><font color="#000000">The FilePermission object allows access to a set
of files based on a wildcarding mechanism. A set of FilePermission objects
may be combined to give any desired degree of access. For example, it is
straightforward to construct a set of two permissions that gives code read-write
access to one directory, and read-only access to a different directory.
FilePermission is described in detail in <i><a href="#Inside Java 2 Platform">Inside
Java 2 Platform Security</a></i>, section 3.6.4.</font>
<p><font color="#000000">A mechanism similar to FilePermission is ideally
suited to the needs of resources that are accessed via Locators. For example,
consider the following set of permissions for an application:</font>
<ul>
<li>
<font color="#000000">An application may select services corresponding
to "channel" 3, 7, or 9 through 11</font></li>

<li>
<font color="#000000">An application may receive program events for "program
X"</font></li>
</ul>
<font color="#000000">This is analogous to the kinds of access that FilePermission
grants. For this reason, important permissions in the Java TV API have
a Locator in their constructor. Using a Locator in this way does not place
any requirements on the internal representation an implementation maintains
for a Locator. It does, however, imply a requirement on the <i>signaling</i>
of permissions. Namely, a permission that relates to a given Locator needs
to be signaled in such a way that the permission object can determine if
it grants access for a given Locator. A signaling specification would probably
define some kind of wildcarding scheme based on paths for Locators, to
facilitate the natural expression of a set of permissions. For example,
the Locator for a service might have a representation equivalent to "/service/physical/channel007"
or "/service/logical/ESPN/TheDeuce". Doing so would allow logical wildcarding
in the signaling of permissions.</font>
<p><font color="#000000">The Java TV API does not mandate a particular
format for Locators. This format must be specified as part of a complete
platform. Despite this, an application running on a platform that implements
the J2SE security model can test whether or not it has access to the resource
corresponding to a given Locator using code similar to the following:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; boolean hasAccessTo(Locator l) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean allowed =
true;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SecurityManager m = System.getSecurityManager();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m != null) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Permission p = new javax.tv.mumble.MumblePermission(l);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m.checkPermission(p);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} catch (SecurityException ex) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
allowed = false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return allowed;<br>
&nbsp;&nbsp;&nbsp;&nbsp; }</font> <br>

<pre>
<hr WIDTH="100%"></pre>
<pre><font color="#000000">Copyright &copy; 2000 Sun Microsystems, Inc.</font></pre>

</body>
</html>
